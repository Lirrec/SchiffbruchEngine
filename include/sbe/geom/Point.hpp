#ifndef TEMPLATES_HPP
#define TEMPLATES_HPP

#include <boost/operators.hpp>
#include <boost/lexical_cast.hpp>
#include <iostream>

namespace sbe
{
	/**
		This namespace holds various Geometry and Math related functions and classes
	*/
	namespace Geom
	{

		/**

			A base clase for points/vectors with 2 elements

		*/
		template <class T>
		class point
			: boost::operators< point<T> >// note: private inheritance is OK here!
			, boost::operators2< point<T>, T >// note: private inheritance is OK here!
	/*		: boost::addable< 		point<T>     // point + point
			: boost::addable< 		point<T>, T  // point + point
			, boost::subtractable< 	point<T>     // point - point
			, boost::subtractable< 	point<T>, T  // point - point
			, boost::dividable< 	point<T>     // point / point
			, boost::dividable< 	point<T>, T  // point / T
			, boost::multipliable< 	point<T> 	  // point * point
			, boost::multipliable< 	point<T>, T  // point * T, T * point
			  > > > > > > > >*/
		{

			public:
				point(T _x, T _y) : x(_x), y(_y) {};
				point() : x(), y() {};

				point operator+=(const point& p) { x += p.x; y += p.y; return *this; }
				point operator+=(const T& t) { x += t; y += t; return *this; }
				// point operator+(point, const point&) automatically
				// generated by addable.

				point operator-=(const point& p) { x -= p.x; y -= p.y; return *this;}
				point operator-=(const T& t) { x -= t; y -= t; return *this;}
				// point operator-(point, const point&) automatically
				// generated by subtractable.

				point operator*=(const point& p) { x *= p.x; y *= p.y; return *this; }
				point operator*=(const T& t) { x *= t; y *= t; return *this; }
				// point operator*(point, const T&) and
				// point operator*(const T&, point) auto-generated
				// by multipliable.

				point operator/=(const point& p) { x /= p.x; y /= p.y; return *this; }
				point operator/=(const T& t) { x /= t; y /= t; return *this; }
				// point operator/(point, const T&) auto-generated
				// by dividable.

				std::string ToString()
				{
					 return boost::lexical_cast<std::string>(x)
							+ '/' +
							boost::lexical_cast<std::string>(y);
				}

				T x;
				T y;
		};

		/// the common Pointi as found in all natural binary habitats
		typedef point<int> Point;
		/// Same as a Point, may be used to stress the semantic usage
		typedef Point Vec2;
		/// the common Pointf as found in all natural binary habitats ( IEEE approved )
		typedef point<float> Pointf;
		/// Same as a Point, may be used to stress the semantic usage
		typedef Pointf Vec2f;

		/// a Rect consists of 2 points, top-left and bottom-right position of the rect
		typedef point<Point> Rect;
		/// a Rect consists of 2 points, top-left and bottom-right position of the rect
		typedef point<Pointf> Rectf;

		/// operator<< overloaded for point<T>s
		template <typename T>
		std::ostream &operator<<(std::ostream &stream, point<T> ob)
		{
		  stream << ob.x << '/' << ob.y ;

		  return stream;
		}

		extern template class point<int>;
		extern template class point<point<int>>;
		extern template class point<float>;
		extern template class point<point<float>>;


	}
} // namespace sbe

namespace Geom = sbe::Geom;

#endif // TEMPLATES_HPP
